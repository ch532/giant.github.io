<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris Pro</title>
<script src="https://bridge.playgama.com/v1/stable/playgama-bridge.js"></script>
<style>
:root { --bg:#000;--card:#1e1e1e;--accent:#0ea5a4;--muted:#999; }
html, body { height: 100%; margin:0; font-family:Inter,Segoe UI,Arial,sans-serif; background:var(--bg); color:#fff; overflow:hidden; }
.wrap { width:100vw; height:100vh; margin:0; padding:16px; display:flex; flex-direction:column; justify-content:center; align-items:center; }
.card { background:var(--card); border-radius:12px; padding:16px; box-shadow:0 6px 18px rgba(0,0,0,.6); }
h1 { margin:6px 0 12px; font-size:22px; }
.row { display:flex; gap:8px; align-items:center; }
.spacer { flex:1; }
#level,#coins { font-weight:600; }
#message { min-height:24px; color:#ffd54d; margin-top:10px; }
.small { font-size:13px; color:var(--muted); }
#controls { margin-top:12px; display:flex; gap:8px; flex-wrap:wrap; }
#game-over { display:none; text-align:center; padding:12px; }
footer { margin-top:16px; text-align:center; color:var(--muted); font-size:13px; }
#iap-buttons { display:flex; gap:8px; justify-content:center; margin-top:10px; flex-wrap:wrap; }
#console { position:fixed; bottom:0; left:0; width:100%; max-height:150px; overflow-y:auto; background:rgba(0,0,0,0.8); color:#0f0; font-family:monospace; font-size:12px; padding:6px; z-index:9999; }
canvas { background:#111; display:block; margin:12px auto; border:2px solid var(--accent); width:100%; height:auto; }
:fullscreen canvas, :-webkit-full-screen canvas { width:100vw !important; height:100vh !important; }
:fullscreen .wrap, :-webkit-full-screen .wrap { width:100vw !important; height:100vh !important; }
</style>
</head>
<body>

<!-- Playgama SDK initialization (do not modify) -->
<script>
bridge.initialize()
    .then(() => {
        // initialization was successful, SDK can be used
    })
    .catch(error => {
        // error, something went wrong
    })
</script>

<div class="wrap" id="gameWrap">
  <div class="card">
    <div class="row">
      <h1>Tetris Pro</h1>
      <div class="spacer"></div>
      <div id="level" class="small">Level: 1</div>
      <div id="coins" class="small">Coins: 0</div>
      <div id="lives" class="small">Lives: <span id="livesCount">5</span></div>
    </div>

    <canvas id="tetris" width="300" height="600"></canvas>
    <div id="message"></div>

    <div id="controls">
      <button class="btn" id="fullscreenBtn">Fullscreen</button>
      <button class="btn" id="pauseBtn">Pause</button>
      <button class="btn" id="playBtn">Play</button>
      <button class="btn" id="restartBtn">Restart</button>
      <button class="btn" id="useCoinBtn">Use 5 Coins → Slow Block</button>
      <button class="btn" id="watch-rewarded">Watch Ad → +20 coins</button>
      <button class="btn" id="daily-bonus">Daily +50</button>
    </div>

    <div id="ad-container" style="margin-top:12px"></div>

    <div id="iap-buttons">
      <button class="btn" id="buy-50">Buy 50</button>
      <button class="btn" id="buy-100">Buy 100</button>
      <button class="btn" id="buy-200">Buy 200</button>
    </div>

    <div id="game-over" class="card">
      <h2>Game Over</h2>
      <div class="small" id="go-info">You ran out of lives.</div>
      <button class="btn primary" id="continueWithAd">Watch Ad to Continue (+1 life)</button>
    </div>
  </div>

  <footer>
    <div class="small">Built with Playgama Bridge SDK • Test build</div>
  </footer>
</div>

<div id="console"></div>

<script>
// Console logger
const c = document.getElementById('console');
function logConsole(...args){ c.innerHTML += args.join(' ') + '<br>'; c.scrollTop = c.scrollHeight; }

// --- Game Variables ---
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const ROWS=20, COLS=10, BLOCK=30;
let field = Array.from({length:ROWS},()=>Array(COLS).fill(0));
let currentBlock = null;
let blockPos = {x:3, y:0};
let dropInterval = 1000;
let dropTimer;
let coins = 0;
let level = 1;
let lives = 5;
let isPaused = false;

// --- UI ---
const levelEl = document.getElementById('level');
const coinsEl = document.getElementById('coins');
const livesEl = document.getElementById('livesCount');
const messageEl = document.getElementById('message');
const gameOverEl = document.getElementById('game-over');

// --- Blocks ---
const BLOCKS = [
  [[1,1],[1,1]], [[0,1,0],[1,1,1]], [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]], [[1,1,1,1]]
];
function randomBlock(){ return BLOCKS[Math.floor(Math.random()*BLOCKS.length)]; }

// --- Draw ---
function draw(){
  ctx.fillStyle="#111"; ctx.fillRect(0,0,COLS*BLOCK,ROWS*BLOCK);
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(field[y][x]){
        ctx.fillStyle=field[y][x]; ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
      }
    }
  }
  if(currentBlock){
    ctx.fillStyle="#0ea5a4";
    for(let y=0;y<currentBlock.length;y++){
      for(let x=0;x<currentBlock[y].length;x++){
        if(currentBlock[y][x]){
          ctx.fillRect((blockPos.x+x)*BLOCK,(blockPos.y+y)*BLOCK,BLOCK,BLOCK);
        }
      }
    }
  }
}

// --- Collision ---
function collides(offsetX=0, offsetY=0){
  for(let y=0;y<currentBlock.length;y++){
    for(let x=0;x<currentBlock[y].length;x++){
      if(currentBlock[y][x]){
        let nx = blockPos.x+x+offsetX;
        let ny = blockPos.y+y+offsetY;
        if(nx<0 || nx>=COLS || ny>=ROWS || (ny>=0 && field[ny][nx])) return true;
      }
    }
  }
  return false;
}

// --- Merge ---
function merge(){
  for(let y=0;y<currentBlock.length;y++){
    for(let x=0;x<currentBlock[y].length;x++){
      if(currentBlock[y][x] && blockPos.y+y>=0) field[blockPos.y+y][blockPos.x+x]="#0ea5a4";
    }
  }
}

// --- Clear lines ---
function clearLines(){
  let lines=0;
  outer: for(let y=ROWS-1;y>=0;y--){
    if(field[y].every(c=>c)){
      field.splice(y,1); field.unshift(Array(COLS).fill(0));
      lines++; y++;
    }
  }
  if(lines>0){
    coins += lines*2;
    messageEl.textContent=`Lines cleared: ${lines} → +${lines*2} coins`;
    updateUI(); saveState();
  }
}

// --- Next Block ---
function nextBlock(){
  currentBlock=randomBlock();
  blockPos={x:3,y:0};
  if(collides()) gameOver();
  draw();
}

// --- Drop ---
function drop(){
  if(isPaused) return;
  if(!collides(0,1)) blockPos.y++;
  else { merge(); clearLines(); nextBlock(); }
  draw();
}

// --- Identity & Storage ---
let playerId;
async function saveState(){
  await bridge.storage.set('coins', coins);
  await bridge.storage.set('level', level);
  await bridge
async function saveState(){
  await bridge.storage.set('coins', coins);
  await bridge.storage.set('level', level);
  await bridge.storage.set('lives', lives);
  logConsole('State saved');
}

async function loadState(){
  const savedCoins = await bridge.storage.get('coins');
  const savedLevel = await bridge.storage.get('level');
  const savedLives = await bridge.storage.get('lives');
  coins = savedCoins ?? 0;
  level = savedLevel ?? 1;
  lives = savedLives ?? 5;
  updateUI();
  logConsole('State loaded');
}

// --- UI Update ---
function updateUI(){
  coinsEl.textContent = `Coins: ${coins}`;
  levelEl.textContent = `Level: ${level}`;
  livesEl.textContent = lives;
}

// --- Game Over ---
function gameOver(){
  clearInterval(dropTimer);
  gameOverEl.style.display = 'block';
  messageEl.textContent = 'Game Over!';
}

// --- Start Game ---
function startGame(){
  loadState().then(() => {
    nextBlock();
    draw();
    clearInterval(dropTimer);
    dropTimer = setInterval(drop, dropInterval);
  });
}

// --- Controls ---
document.addEventListener('keydown', (e) => {
  if(isPaused) return;
  if(e.key === 'ArrowLeft' && !collides(-1,0)) blockPos.x--;
  if(e.key === 'ArrowRight' && !collides(1,0)) blockPos.x++;
  if(e.key === 'ArrowDown') drop();
  if(e.key === ' ') { // rotate
    const n = currentBlock.length;
    const temp = Array.from({length:n}, ()=>Array(n).fill(0));
    for(let y=0;y<n;y++) for(let x=0;x<n;x++) temp[x][n-1-y]=currentBlock[y][x];
    const old=currentBlock; currentBlock=temp;
    if(collides()) currentBlock=old;
  }
  draw();
});

// --- Button Actions ---
document.getElementById('fullscreenBtn').onclick = () => {
  const gameWrap = document.getElementById('gameWrap');
  if (gameWrap.requestFullscreen) gameWrap.requestFullscreen();
  else if (gameWrap.webkitRequestFullscreen) gameWrap.webkitRequestFullscreen();
  else if (gameWrap.msRequestFullscreen) gameWrap.msRequestFullscreen();
};

document.getElementById('pauseBtn').onclick = () => { isPaused=true; messageEl.textContent='⏸ Paused'; };
document.getElementById('playBtn').onclick = () => { isPaused=false; messageEl.textContent='▶ Playing'; };
document.getElementById('restartBtn').onclick = () => {
  field = Array.from({length:ROWS},()=>Array(COLS).fill(0));
  coins = 0; level = 1; lives = 5;
  gameOverEl.style.display='none';
  updateUI();
  startGame();
};
document.getElementById('useCoinBtn').onclick = () => {
  if(coins >= 5){ coins-=5; dropInterval+=300; messageEl.textContent='Block slowed!'; updateUI(); saveState(); }
  else messageEl.textContent='Not enough coins!';
};
document.getElementById('daily-bonus').onclick = () => { coins+=50; messageEl.textContent='Daily bonus added!'; updateUI(); saveState(); };
document.getElementById('buy-50').onclick = () => { coins+=50; updateUI(); saveState(); };
document.getElementById('buy-100').onclick = () => { coins+=100; updateUI(); saveState(); };
document.getElementById('buy-200').onclick = () => { coins+=200; updateUI(); saveState(); };
document.getElementById('continueWithAd').onclick = () => { showRewardedAd(()=>{ lives++; gameOverEl.style.display='none'; updateUI(); }); };

// --- Ads ---
function showRewardedAd(callback){
  bridge.ads.show('rewarded').then(()=>{ logConsole('Rewarded ad shown'); callback(); })
  .catch(err=>logConsole('Rewarded ad error',err));
}
function showInterstitialAd(){
  bridge.ads.show('interstitial').then(()=>logConsole('Interstitial ad shown'))
  .catch(err=>logConsole('Interstitial ad error',err));
}
function showBannerAd(){
  bridge.ads.show('banner',{container:'#ad-container'}).then(()=>logConsole('Banner ad shown'))
  .catch(err=>logConsole('Banner ad error',err));
}

// --- Identity ---
bridge.identity.get()
  .then(id => { playerId = id; logConsole('Player ID:', playerId); })
  .catch(err => logConsole('Identity error', err));

// --- Start ---
startGame();
showBannerAd();
setInterval(showInterstitialAd, 120000); // every 2 mins
</script>

</body>
</html>
  
